const express = require('express');
const userRoutes = express.Router();
const db = require('../db.js');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const multer = require('multer');
const path = require('path');

const pool = db.getPool();
console.log('console.log test');
console.error('console.error test');
// Configure Multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, path.join(__dirname, '../dist/assets/profile/user/')); // Store in assets/profile
  },
  filename: (req, file, cb) => {
    const user_id = req.params.user_id; // Get user ID from request params
    const fileExt = path.extname(file.originalname); // Get file extension
    cb(null, `user_${user_id}${fileExt}`); // Generate unique filename
  },
});

const upload = multer({ storage: storage });

// Test database connection
userRoutes.get('/testuser', async (req, res) => {
  // Declare the variable name 'client' here so it's accessible everywhere in scope
  let client; 
  try {
    // Acquire the connection into the 'client' variable
    client = await pool.getConnection(); 
    console.log('Successfully acquired connection from pool.');
    
    // Use the 'client' variable to execute the query
    const result = await client.query('SELECT 1 + 1 AS test');
    
    res.json({ message: 'Database connection successful', result: result[0] });
    
    // Use the 'client' variable to release the connection
    client.release();

  } catch (err) {
    console.error('Error testing connection:', err);
    res.status(500).json({ error: 'Database connection error' });
  }
});

userRoutes.get('/', async (req, res, next) => {
  try{
    client = await pool.getConnection(); 
    const result = await client.query('SELECT * FROM users inner join role on users.role_id = role.role_id');;
    client.release();
    res.status(201).json(result.rows);
  }
  catch (error) {
    console.error("Error getting all users:", error);
    return res.status(500).json({ error: 'Failed to get all users' });;
  }
}); 

// Register a new user
userRoutes.post('/addUser', async (req, res, next) => {
  let client; // Declare client for proper scope/cleanup
  try {
    //console.error("req", req); // Keep this commented unless actively debugging
    client = await pool.getConnection(); 
    const { first_name, last_name, address, city, state, zip_code, email, username, password} = req.body;
    
    // 1. Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // 2. Execute the INSERT query (Standard MySQL syntax)
    // NOTE: Removed 'RETURNING *' as it's not standard MySQL
    const [insertResult] = await client.query( 
      'INSERT INTO users (first_name, last_name, address, city, state, zip_code, email, username, password) VALUES (?,?,?,?,?,?,?,?,?)',
      [first_name, last_name, address, city, state, zip_code, email, username, hashedPassword]
    );

    const newUserId = insertResult.insertId;
    
    // 3. Fetch the newly created user (required because INSERT doesn't return the row)
    const [userRows] = await client.query('SELECT * FROM users WHERE user_id = ?', [newUserId]);

    client.release();
    
    // 4. Return the new user data
    if (userRows && userRows.length > 0) {
        res.status(201).json(userRows[0]);
    } else {
        // Fallback error if user wasn't found after successful insert
        res.status(500).json({ error: 'User registered but failed to retrieve user data' });
    }
  } catch (error) {
    if (client) client.release(); // Release connection on error
    console.error("Error registering user:", error);
    // You might want to check for duplicate entry errors (e.g., duplicate email/username) here
    res.status(500).json({ error: 'Failed to register user' });
  }
});

// Login a user
userRoutes.post('/login', async (req, res, next) => {
  try {
    client = await pool.getConnection(); 
    const { username, password } = req.body;

    const result = await client.query('SELECT * FROM users inner join role on users.role_id = role.role_id WHERE username = $1', [username]);
    client.release();

    if (result.rows.length === 0) {
      return res.status(401).json({ error: 'Invalid Username' });
    }

    const user = result.rows[0];
    const passwordMatch = await bcrypt.compare(password, user.password);

    if (!passwordMatch) {
      return res.status(401).json({ error: 'Invalid Username or Password' });
    }

    const token = jwt.sign(
      {
        user_id: user.user_id,
        username: user.username,
        first_name: user.first_name,
        last_name: user.last_name,
        address: user.address,
        city: user.city,
        state: user.state,
        zip_code: user.zip_code,
        role_id: user.role_id,
      },
      'your_jwt_secret',
      { expiresIn: '1h' }
    );

    res.json({
      user: {
        user_id: user.user_id,
        username: user.username,
        first_name: user.first_name,
        last_name: user.last_name,
        address: user.address,
        city: user.city,
        state: user.state,
        zip_code: user.zip_code,
        role_id: user.role_id,
        role_name: user.role_name,
      },
      token,
    });

  } catch (error) { // Correctly placed catch block
    console.error("Error logging in user:", error);
    res.status(500).json({ error: 'Login failed' });
  } // End of try block (missing before!)  This was the problem!
});

// Delete a user
userRoutes.delete('/:user_id', async (req, res) => {
  try {
    const user_id = parseInt(req.params.user_id);
    client = await pool.getConnection(); 
    const { rows } = await client.query('DELETE FROM users WHERE user_id = $1 RETURNING *', [user_id]);
    client.release();

    if (rows.length === 0) {
      res.status(404).json({ error: 'Event not found' });
    } else {
      res.status(204).send(); // 204 No Content for successful delete
    }
  } catch (err) {
    console.error('Error deleting event:', err);
    res.status(500).json({ error: 'Failed to delete event' });
  }
});

// Update an existing user with optional profile picture upload
userRoutes.put('/:user_id', upload.single('profilePicture'), async (req, res) => {
  try {
    const user_id = parseInt(req.params.user_id);
    const { first_name, last_name, address, city, state, zip_code, username, email, role_id, our_team, about_me, team_order } = req.body;
    let profile_picture = null;

    if (req.file) {
      profile_picture = req.file.filename; // Store only the filename
    } else {
      // Fetch the existing profile_picture from the database
      const client = await db.getPool().connect();
      const { rows } = await client.query(
        'SELECT profile_picture FROM users WHERE user_id = $1',
        [user_id]
      );
      client.release();

      if (rows.length > 0 && rows[0].profile_picture) {
        profile_picture = rows[0].profile_picture; // Use existing value
      } else {
          profile_picture = null; // if no file uploaded, and no existing value, set to null.
      }
    }

    client = await pool.getConnection(); 
    const { rows } = await client.query(
      'UPDATE users SET first_name = $1, last_name = $2, address = $3, city = $4, state = $5, zip_code = $6, username = $7, email = $8, role_id = $9, our_team = $10, about_me = $11, team_order = $12, profile_picture = $13 WHERE user_id = $14 RETURNING *',
      [first_name, last_name, address, city, state, zip_code, username, email, role_id, our_team, about_me, team_order, profile_picture, user_id]
    );
    client.release();

    if (rows.length === 0) {
      res.status(404).json({ error: 'User not found' });
    } else {
      res.json(rows[0]);
    }
  } catch (err) {
    console.error('Error updating user:', err.message, err.stack);
    res.status(500).json({ error: 'Failed to update user' });
  }
});

module.exports = userRoutes;
